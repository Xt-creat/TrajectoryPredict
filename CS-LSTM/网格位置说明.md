# 网格位置计算说明

## 网格布局结构

网格是一个 **13列（纵向）× 3行（横向车道）** 的空间布局，共39个位置：

```
        列0  列1  列2  ...  列12
行0  [  1    2    3   ...   13  ]  ← 左车道（lane-1）
行1  [ 14   15   16  ...   26  ]  ← 本车道（lane，目标车辆所在车道）
行2  [ 27   28   29  ...   39  ]  ← 右车道（lane+1）
```

- **行0（左车道）**：网格索引 1-13
- **行1（本车道）**：网格索引 14-26
- **行2（右车道）**：网格索引 27-39

## 网格位置的计算（预处理阶段）

在 `preprocess_data.py` 中，网格位置是根据以下信息计算的：

### 1. 车道信息
- 目标车辆所在车道：`lane`
- 左车道：`lane - 1`（如果存在）
- 本车道：`lane`
- 右车道：`lane + 1`（如果存在）

### 2. 纵向距离
- `y = 邻居车辆的LocalY - 目标车辆的LocalY`
- 只考虑 `|y| < 90` 英尺范围内的邻居（约27米）

### 3. 网格索引计算公式

#### 左车道（行0，索引1-13）：
```python
y = 邻居车辆的LocalY - 目标车辆的LocalY
if abs(y) < 90:
    gridInd = 1 + round((y + 90) / 15)
    # gridInd 范围：1-13
```

#### 本车道（行1，索引14-26）：
```python
y = 邻居车辆的LocalY - 目标车辆的LocalY
if abs(y) < 90 and y != 0:  # 排除目标车辆自己
    gridInd = 14 + round((y + 90) / 15)
    # gridInd 范围：14-26
```

#### 右车道（行2，索引27-39）：
```python
y = 邻居车辆的LocalY - 目标车辆的LocalY
if abs(y) < 90:
    gridInd = 27 + round((y + 90) / 15)
    # gridInd 范围：27-39
```

### 4. 公式说明

- `(y + 90) / 15`：将纵向距离从 `[-90, +90]` 映射到 `[0, 12]`
- `round(...)`：四舍五入到最近的整数
- `+ base`：根据车道添加基础偏移量（1, 14, 或 27）

### 5. 距离分段

每个网格位置代表约15英尺（约4.5米）的纵向距离：

```
左车道：
  索引1:  y = -90 到 -75 英尺（目标车辆后方）
  索引2:  y = -75 到 -60 英尺
  ...
  索引7:  y = -15 到   0 英尺（目标车辆位置）
  索引8:  y =   0 到 +15 英尺（目标车辆前方）
  ...
  索引13: y = +75 到 +90 英尺

本车道（类似，但索引从14开始）
右车道（类似，但索引从27开始）
```

## 数据存储

在预处理后的数据中：
- **列9-47**：存储39个网格位置的车辆ID
- 如果某个网格位置有邻居车辆，存储该车辆的ID
- 如果没有邻居，存储0

## 数据加载阶段（utils.py）

### 1. 读取网格信息
```python
grid = self.D[idx, 9:9+39]  # 39个网格位置的车辆ID
```

### 2. 获取邻居轨迹
```python
for i in grid:
    neighbors.append(self.getHistory(i.astype(int), t, vehId, dsId))
```
- `neighbors` 是一个长度为39的列表
- 每个元素是对应网格位置的邻居车辆历史轨迹
- 如果没有邻居，对应元素为空数组 `[]`

### 3. 构建掩码（collate_fn）

在 `collate_fn` 中，根据网格索引计算网格的行列位置：

```python
for id, nbr in enumerate(neighbors):  # id: 0-38（网格索引-1）
    if len(nbr) != 0:  # 如果这个网格位置有邻居
        pos[0] = id % self.grid_size[0]   # 列位置 (0-12)
        pos[1] = id // self.grid_size[0]  # 行位置 (0-2)
        mask_batch[sampleId, pos[1], pos[0], :] = 1
```

**索引转换**：
- `id` 是 `neighbors` 列表的索引（0-38）
- `id` 对应网格索引（1-39）
- `pos[0] = id % 13`：列位置（0-12）
- `pos[1] = id // 13`：行位置（0-2）

**示例**：
- `id = 5`（网格索引6，左车道第6个位置）
  - `pos[0] = 5 % 13 = 5`（列5）
  - `pos[1] = 5 // 13 = 0`（行0，左车道）
  
- `id = 20`（网格索引21，本车道第8个位置）
  - `pos[0] = 20 % 13 = 7`（列7）
  - `pos[1] = 20 // 13 = 1`（行1，本车道）

## 重要说明：网格位置的固定性

### 问题：网格位置是否随时间变化？

**答案：网格位置是固定的，基于当前时间点t**

### 设计原理

1. **网格位置计算时间点**：
   - 网格位置是在**当前时间点t**计算的（`preprocess_data.py` 第154行）
   - 这是预测的"当前时刻"的空间上下文

2. **邻居历史轨迹的时间范围**：
   - 邻居车辆的历史轨迹是从 `t - t_h` 到 `t` 的16个时间步
   - 在16个时间步中，邻居车辆可能：
     - 移动到不同的网格位置
     - 甚至移动到不同的车道
     - 但模型仍然使用时间点t的网格位置

3. **为什么这样设计是合理的？**

   **时间尺度考虑**：
   - 16个时间步 = 30帧（原始）→ 16帧（下采样后）
   - 采样率：10Hz（每帧0.1秒）
   - 下采样率：2（每2帧取1帧）
   - 实际时间跨度：30帧 × 0.1秒 = **3秒**（原始），或 **1.6秒**（下采样后）
   
   **在这么短的时间内**：
   - 车辆通常不会大幅移动（高速公路场景）
   - 车辆通常不会变道（3秒内变道较少见）
   - 相对位置变化较小
   
   **设计理念**：
   - 网格位置代表的是"**当前时刻的空间上下文**"
   - 用于理解当前时刻的交通环境
   - 邻居的历史轨迹提供的是"**该车辆的运动模式**"
   - 两者结合：空间位置（当前）+ 运动模式（历史）

4. **实际影响**：
   - 在大多数情况下，邻居车辆在3秒内不会大幅移动
   - 即使有轻微移动，网格位置仍然能提供有效的空间上下文
   - 卷积操作能够捕捉局部空间关系，对轻微的位置变化有一定的鲁棒性

5. **潜在改进方向**（如果需要）：
   - 可以为每个时间步计算不同的网格位置
   - 但这会增加计算复杂度
   - 对于3秒的时间窗口，当前设计已经足够有效

## 总结

1. **预处理阶段**：根据邻居车辆的车道和纵向距离，计算网格索引（1-39），存储在数据中
2. **数据加载阶段**：从数据中读取网格信息，获取每个网格位置的邻居车辆轨迹
3. **批次构建阶段**：根据网格索引计算行列位置，构建掩码，标记哪些网格位置有邻居
4. **网格位置固定性**：网格位置基于当前时间点t，在整个16个时间步的历史轨迹中保持不变

这样，模型就能知道每个邻居车辆在空间网格中的具体位置，从而进行卷积社会池化操作。

